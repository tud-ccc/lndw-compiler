_version: 2
app:
  default_name:
    en: CCC Compiler Demo - TUD Chair for Compiler Construction
  english:
    en: English
    de: Englisch
  german:
    en: German
    de: Deutsch
  tools:
    en: Tools
    de: Fenster
  optimizations:
    en: Optimizations
    de: Optimierungen
  organize:
    en: Organize windows
    de: Fenster ordnen
  reset:
    en: Reset egui memory
  forget:
    en: Forget scroll, positions, sizes etc
  change_title:
    en: Change app title
    de: App-Titel √§ndern
output:
  unopt:
    en: Unoptimized output
    de: Unoptimierter Ausgabe
  opt:
    en: Optimized output
    de: Optimierter Ausgabe
  empty:
    en: Assembly output will be here
    de: Die Assembler-Ausgabe wird hier erscheinen
  time:
    en: "Total time: %{t} sec"
    de: "Gesamtdauer: %{t} s"
  result:
    en: Program result is %{res}
    de: Ergebnis ist %{res}
  registers:
    en: Registers
    de: Registern
  ram:
    en: Main memory
    de: Hauptspeicher
  ram.cell:
    en: Cell
    de: Zelle
  ram.content:
    en: Content
    de: Inhalt
  executing:
    en: Currently executing
    de: Wird gerade ausgef√ºhrt
  step:
    button:
      en: Run next step
      de: N√§chster Schritt
    desc:
      en: Executes the next instruction in the list
      de: F√ºhrt den n√§chsten Befehl in der Liste aus
  to_finish:
    button:
      en: Run to end
      de: Rest ausf√ºhren
    desc:
      en: Executes the whole rest of the program without waiting.
      de: F√ºhrt alle restlichen Befehle bis zum Ende des Programms aus.
editor:
  name:
    en: üñÆ Code Editor
    de: üñÆ Code-Editor
  explain:
    en: You can write your expressions in this TextEdit box.
    de: In dieses Textfeld k√∂nnen Sie einen Ausdruck schreiben.
  constant_folding:
    en: Constant folding
    de: Konstantenfaltung
  cache_opt:
    en: RAM optimization
    de: RAM-Optimierung
  common_factor_elimination:
    en: Common Factor Extraction
    de: Faktorisierung
  replace_mul_with_shift:
    en: Replace factors with bitshifts
    de: Ersetze Faktoren durch Bit-Verschiebung
  compile:
    en: Compile!
    de: Kompilieren!
  run:
    en: Run!
    de: Ausf√ºhren!
  run.alt:
    en: You can alternatively press CTRL+Enter to compile and run
    de: Alternativ k√∂nnen Sie CTRL+Enter dr√ºcken, um zu kompilieren und auszuf√ºhren
  step:
    en: Step by Step
    de: Schritt f√ºr Schritt
  clear:
    en: Clear
    de: L√∂schen
  inputs:
    en: "Input variables:"
    de: "Eingabevariablen:"
compiler:
  error:
    divzero:
      en: attempted division by zero
      de: versuchte Division durch Null
    invalid_unary:
      en: invalid unary operator `%{op}`
      de: ung√ºltiger un√§rer Operator `%{op}`
    unknown_var:
      en: unknown variable
      de: unbekannte Variable `%{v}`
    empty_var:
      en: no value given for variable %{v}
      de: kein Wert f√ºr Variable %{v} angegeben
    nan_var:
      en: variable %{var}'s value `%{val}` is not a number
      de: der Wert der Variablen %{var} `%{val}` ist keine Zahl
  inst:
    add:
      en: add register %{a} to register %{b}
      de: Register %{a} zu Register %{b} addieren
    sub:
      en: subtract register %{a} from register %{b}
      de: Register %{a} von Register %{b} subtrahieren
    mul:
      en: multiply register %{a} by register %{b}
      de: Register %{a} mit Register %{b} multiplizieren
    div:
      en: divide register %{a} by register %{b}
      de: Register %{a} durch Register %{b} dividieren
    shl:
      en: shift value in register %{a} left by value in register %{b}
      de: Register %{a} um Register %{b} nach links schieben
    shr:
      en: shift value in register %{a} right by value in register %{b}
      de: Register %{a} um Register %{b} nach rechts schieben
    store:
      en: store the number %{n} in register %{r}
      de: die Zahl %{n} im Register %{r} speichern
    transfer:
      en: transfer variable %{v} to register %{r}
      de: √ºbertragen der Variablen %{v} in das Register %{r}
    result:
      en: the result is in register %{r}
      de: das Ergebnis steht im Register %{r}
    write:
      en: write register %{r} to main memory (cell %{addr})
      de: Register %{r} in den Hauptspeicher schreiben (Zelle %{addr})
    load:
      en: load main memory cell %{addr} into register %{r}
      de: Laden der Hauptspeicherzelle %{addr} in das Register %{r}
interp_opts:
  name:
    en: Interpreter options
    de: Interpreter-Optionen
  label:
    en: These are the settings for the Interpreter executing the code. Change them and see how the compile results change with more or less RAM cells or registers.
    de: Dies sind die Einstellungen f√ºr den Interpreter, der den Code ausf√ºhrt. √Ñndern Sie sie und sehen Sie, wie sich die Kompilierergebnisse mit mehr oder weniger RAM-Zellen oder Registern √§ndern.
  explanation:
    en: Explanation
    de: Erl√§uterung
  n_regs:
    en: Register count
    de: Anzahl der Registern
  label_regs:
    en: A computer processor can remember a fixed number of things. They work like post-its on your monitor. There's space for a few and you have them always ready.
    de: Ein Computerprozessor kann sich eine bestimmte Anzahl von Dingen merken. Sie funktionieren wie Post-its auf dem Monitor. Da ist Platz f√ºr ein paar und man hat sie immer parat.
  cache_size:
    en: RAM size
    de: RAM-Gr√∂√üe
  cache_label:
    en: If all registers are full, computers have larger storages, called RAM. While they're bigger, they're also slower to access. Think of them like big binders of files. They can hold a lot of paper, but finding a specific page takes time.
    de: Wenn alle Register voll sind, haben Computer gr√∂√üere Speicher, den so genannten RAM. Der ist zwar gr√∂√üer, aber der Zugriff ist auch langsamer. Stell Dir diese Speicher wie gro√üe Aktenordner vor. Sie k√∂nnen eine Menge Papier aufnehmen, aber das Auffinden einer bestimmten Seite braucht Zeit.
examples:
  name:
    en: Examples
    de: Beispiele
  use:
    en: Use this!
    de: Ausprobieren!
  basic:
    title:
      en: A Simple Addition
      de: Einfach Addition
    desc:
      en: A timeless classic. :)
      de: Ein Zeitloser Klassiker des Alltags. :)
  complex:
    title:
      en: A complex example
      de: Ein kompliziertes Beispiel
    desc:
      en: A more complex example designed to showcase the power and limitations of optimizations. Try RAM optimizations, constant folding and shift optimizations.
      de: Ein komplizierteres Beispiel, das das Potenzial und die Grenzen von Compiler-Optimierungen zeigen soll. Probiere Konstantenfaltung, RAM-Optimierung und Bitshift-Optimierung.
  ram_opt:
    title:
      en: RAM optimization
      de: RAM Optimierung
    desc:
      en: When a computer runs out of registers, it needs to make place by moving some data to RAM, a large, but very slow memory. This example showcases how removing unnecessary store optimizations speeds up execution.
      de: Wenn dem Computer die freien Register ausgehen, muss er Platz schaffen, indem er Daten in den Arbeitsspeicher verschiebt, einen sehr gro√üen, aber langsamen Speicher. Diese Optimierung demonstriert, wie das 'Ausmisten' unn√∂tiger Speicher-Operationen die Ausf√ºhrung beschleunigt.
  shift_mul:
    title:
      en: Cheaper Multiplication
      de: Schnelles Multiplizieren
    desc:
      en: Some multiplications are much easier for us than others. Take 16 * 10 for example. You immediately know that you only need to add a 0 at the end. It's the same for computers. But since their math works slightly different, with 1s and 0s, they can do the same trick with numbers that are a power of 2.
      de: Manche Multiplikationsaufgaben sind f√ºr uns einfacher als andere. 16 * 10 zum Beispiel. Du wei√üt sofort, dass du nur eine Null am Ende anh√§ngen musst. Bei Computern ist das genau so. Aber weil sie ein bisschen anders rechnen als wir, n√§mlich mit Einsen und Nullen, k√∂nnen sie den gleichen Trick nur mit Zahlen, die eine Potenz von 2 sind, anwenden.
  factorization:
    title:
      en: Factorization
      de: Faktorisierung
    desc:
      en: Computers also profit from mathematical rules we learned in school. Since multiplications and divisions are especially costly, it makes sense to try and use mathematical laws to extract common factors.
      de: Computer profitieren auch von den einfachen Rechenregeln, die wir Menschen in der Schule lernen. Da Multiplikation und Division besonders teuer sind, ergibt es Sinn, mathematische Gesetze wie Faktorisierung anzuwenden.
